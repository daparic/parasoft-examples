/***********************************************************************/
/*                                                                     */
/*  FILE        :lowsrc.c                                              */
/*  DATE        :Tue, Nov 09, 2010                                     */
/*  DESCRIPTION :Program of I/O Stream                                 */
/*  CPU TYPE    :SH7760                                                */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.16).    */
/*                                                                     */
/***********************************************************************/
                  



#include <string.h>
#include <stdio.h>
#include <stddef.h>
#include "typedefine.h"
#include "lowsrc.h"

_SINT open(_SBYTE *name, _SINT mode, _SINT flg);
_SINT close(_SINT fileno);
_SINT read(_SINT fileno, _SBYTE *buf, _UINT count);
_SINT write(_SINT fileno, _SBYTE *buf, _UINT count);
_SDWORD lseek(_SINT fileno, _SDWORD offset, _SINT base);
void _INIT_IOLIB(void);
void _CLOSEALL(void);


/* file number */

#define STDIN  0        /* Standard input (console)        */
#define STDOUT 1        /* Standard output (console)       */
#define STDERR 2        /* Standard error output (console) */

#define FLMIN  0               /* Minimum file number     */
#define FLMAX  (IOSTREAM-1)    /* Maximum number of files */

/* file flag */

#define O_RDONLY 0x0001     /* Read only           */
#define O_WRONLY 0x0002     /* Write only          */
#define O_RDWR   0x0004     /* Both read and Write */

/* special character code */

#define CR 0x0d     /* Carriage return */
#define LF 0x0a     /* Line feed       */

const _SINT _nfiles = IOSTREAM;
struct _iobuf _iob[IOSTREAM];
_UBYTE sml_buf[IOSTREAM];


/***************************************************************************/
/* Declaration of reference function                                       */
/* Reference to assembly program in which the simulator debugger inputs or */
/* outputs characters to the console                                       */
/***************************************************************************/
extern void charput(_SBYTE);     /* One character output */
extern _SBYTE charget(void);     /* One character input  */

/*****************************************************************************/
/* Definition of static variables:                                           */
/* Definition of static variables used in low-level interface routines       */
/*****************************************************************************/
_SBYTE flmod[IOSTREAM];             /* Open file mode specification area */

/***************************************************************************/
/*    open: file open                                                      */
/*          Return value: File number (Pass)                               */
/*                        -1          (Failure)                            */
/***************************************************************************/
_SINT open(_SBYTE *name,         /* File name           */
     _SINT mode,                 /* File mode           */
     _SINT flg)                  /* Unused              */
{
       /* Checks mode depending on file name and returns file numbers */

       if(strcmp(name,"stdin")==0){         /* Standard input file    */
             if((mode&O_RDONLY)==0){
                      return -1;
             }
             flmod[STDIN] = mode;
             return STDIN;
       }

       else if(strcmp(name,"stdout")==0){   /* Standard output file   */
             if((mode&O_WRONLY)==0){
                      return -1;
             }
             flmod[STDOUT] = mode;
             return STDOUT;
       }

       else if(strcmp(name,"stderr")==0){	/* Standard error file    */
             if((mode&O_WRONLY)==0){
                      return -1;
             }
             flmod[STDERR] = mode;
             return STDERR;
       }

       else {
             return -1;		/* Error */
       }
}

/*****************************************************************************/
/*   close: File close                                                       */
/*          Return value: 0  (Pass)                                          */
/*                        -1 (Failure)                                       */
/*****************************************************************************/
_SINT close(_SINT fileno)        /* File number */
{
       if((fileno<FLMIN) || (FLMAX<fileno)){     /* File number range check */
             return -1;
       }
       flmod[fileno] = 0;        /* File mode reset */
       return 0;
}

/*****************************************************************************/
/* read: Data read                                                           */
/*       Return value: Number of read characters (Pass)                      */
/*                     -1                         (Failure)                  */
/*****************************************************************************/
_SINT read(_SINT fileno,         /* File number                */
     _SBYTE *buf,                /* Destination buffer address */
     _UINT count)                /* Number of read characters  */
{
       _UINT i;

       /* Checks mode according to file no. and stores each character in buffer */

       if((flmod[fileno]&O_RDONLY) || (flmod[fileno]&O_RDWR)){
             for(i = count; i > 0u; i--){
                   *buf = charget();
                   if(*buf==CR){        /* Line feed character replacement */
                         *buf = LF;
                   }
                   buf++;
             }
             return count;
       }
       else {
             return -1;
       }
}
 
/****************************************************************************/
/* write: Data write                                                        */
/*        Return value: Number of write characters (Pass)                   */
/*                      -1                         (Failure)                */
/****************************************************************************/
_SINT write(_SINT fileno,        /* File number */
     _SBYTE *buf,                /* Destination buffer address */
     _UINT count)                /* Number of write characters */
{
       _UINT i;
       _SBYTE c;

       /* Checks mode according to file no. and outputs each character */

       if((flmod[fileno]&O_WRONLY) || (flmod[fileno]&O_RDWR)){
             for(i = count; i > 0u; i--){
                   c = *buf++;
                   charput(c);
             }
             return count;
       }
       else {
             return -1;
       }
}

/*****************************************************************************/
/* lseek: Definition of file read/write position                             */
/*      Return value: Offset from the top of file read/write position (Pass) */
/*                    -1              (Failure)                              */
/*        (lseek is not supported in the console input/output)               */
/*****************************************************************************/
_SDWORD lseek(int fileno,        /* File number */
       _SDWORD offset,           /* Read/write position */
       _SINT base)               /* Origin of offset */
{
       return -1L;
}

/****************************************************************************/
/* _INIT_IOLIB                                                              */
/****************************************************************************/
void _INIT_IOLIB(void)
{
       FILE *fp;

       for(fp = _iob; fp < _iob+_nfiles; fp++){  // Set initial values for FILE-type data
             fp->_bufptr = NULL;
             fp->_bufcnt = 0L;
             fp->_buflen = 0L;
             fp->_bufbase = NULL;
             fp->_ioflag1 = 0;
             fp->_ioflag2 = 0;
             fp->_iofd = 0;
       }

       if(freopen("stdin", "r", stdin)==NULL){      // Open standard I/O file
             stdin->_ioflag1 = 0xff;                // Forbid file access if open fails
       }
       stdin->_ioflag1 |= _IOUNBUF;                 // Set without data buffering

       if(freopen("stdout", "w", stdout)==NULL){    // Open standard I/O file
             stdout->_ioflag1 = 0xff;               // Forbid file access if open fails
       }
       stdout->_ioflag1 |= _IOUNBUF;                // Set without data buffering

       if(freopen("stderr", "w", stderr)==NULL){    // Open standard error file
             stderr->_ioflag1 = 0xff;               // Forbid file access if open fails
       }
       stderr->_ioflag1 |= _IOUNBUF;                // Set without data buffering
}

/****************************************************************************/
/* _CLOSEALL                                                                */
/****************************************************************************/
void _CLOSEALL(void)
{
       _SINT i;

       for(i = 0; i < _nfiles; i++){
             // Check to see whether the file is open or not
             if(_iob[i]._ioflag1 & (_IOREAD | _IOWRITE | _IORW )){
                     fclose(& _iob[i]);      // Close the file
             }
       }
}
